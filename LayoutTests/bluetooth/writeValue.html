<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharness-helpers.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="bluetooth-helpers.js"></script>
<script>
test(function(t) { assert_exists(window, 'testRunner'); t.done(); },
     'window.testRunner is required for the following tests.');

sequential_promise_test(function() {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return requestDeviceWithKeyDown({
    filters: [{services: ['generic_access']}]
  }).then(function(device) {
    return device.connectGATT();
  }).then(function(gattServer) {
    return gattServer.getPrimaryService('generic_access');
  }).then(function(service) {
    return service.getCharacteristic('device_name');
  }).then(function(characteristic) {
    testRunner.setBluetoothMockDataSet('EmptyAdapter');
    return characteristic.writeValue(new ArrayBuffer(1 /* length */)).then(function() {
      assert_unreached('Device went out of range, should fail.');
    }, function(e) {
      assert_equals(e.name, 'NetworkError');
      assert_equals(e.message, 'Bluetooth Device is no longer in range.');
    });
  });
}, 'Device goes out of range. Reject with NetworkError.');

sequential_promise_test(function() {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return requestDeviceWithKeyDown({filters: [{services: ['generic_access']}]})
    .then(device => device.connectGATT())
    .then(gattServer => gattServer.getPrimaryService('generic_access'))
    .then(service => service.getCharacteristic('device_name'))
    .then(characteristic => {
      testRunner.setBluetoothMockDataSet('MissingServiceGenericAccessAdapter');
      return characteristic.writeValue(new ArrayBuffer(1 /* length */)).then(() => {
        assert_unreached('Service got removed should fail');
      }, function(error) {
        assert_equals(error.name, 'InvalidStateError');
        assert_equals(error.message, 'GATT Service no longer exists.');
      });
    });
}, 'Service gets removed. Reject with InvalidStateError.');

sequential_promise_test(function() {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return requestDeviceWithKeyDown({filters: [{services: ['generic_access']}]})
    .then(device => device.connectGATT())
    .then(gattServer => gattServer.getPrimaryService('generic_access'))
    .then(service => service.getCharacteristic('device_name'))
    .then(characteristic => {
      testRunner.setBluetoothMockDataSet('MissingCharacteristicGenericAccessAdapter');
      return characteristic.writeValue(new ArrayBuffer(1 /* length */)).then(() => {
        assert_unreached('Characteristic got removed. Should fail.');
      }, error => {
        assert_equals(error.name, 'InvalidStateError');
        assert_equals(error.message, 'GATT Characteristic no longer exists.');
      });
    });
}, 'Characteristic gets removed. Reject with InvalidStateError.');

// The following tests make sure the Web Bluetooth implementation
// responds correctly to the different types of errors the
// underlying platform might return for GATT operations.

// Each implementation maps these characteristics to specific code paths
// that result in different errors thus increasing code coverage
// when testing. Therefore some of these characteristics might not be useful
// for all implementations.
[{
  testName: 'GATT Error: Unknown.',
  uuid: errorUUID(0xA1),
  errorType: 'NotSupportedError',
  message: 'GATT Error Unknown.'
}, {
  testName: 'GATT Error: Failed.',
  uuid: errorUUID(0xA2),
  errorType: 'NotSupportedError',
  message: 'GATT operation failed for unknown reason.'
}, {
  testName: 'GATT Error: In Progress.',
  uuid: errorUUID(0xA3),
  errorType: 'NetworkError',
  message: 'GATT operation already in progress.'
}, {
  testName: 'GATT Error: Invalid Length.',
  uuid: errorUUID(0xA4),
  errorType: 'InvalidModificationError',
  message: 'GATT Error: invalid attribute length.'
}, {
  testName: 'GATT Error: Not Permitted.',
  uuid: errorUUID(0xA5),
  errorType: 'NotSupportedError',
  message: 'GATT operation not permitted.'
}, {
  testName: 'GATT Error: Not Authorized.',
  uuid: errorUUID(0xA6),
  errorType: 'SecurityError',
  message: 'GATT operation not authorized.'
}, {
  testName: 'GATT Error: Not Paired.',
  uuid: errorUUID(0xA7),
  // TODO(ortuno): Change to InsufficientAuthenticationError or similiar
  // once https://github.com/WebBluetoothCG/web-bluetooth/issues/137 is
  // resolved.
  errorType: 'NetworkError',
  message: 'GATT Error: Not paired.'
}, {
  testName: 'GATT Error: Not Supported.',
  uuid: errorUUID(0xA8),
  errorType: 'NotSupportedError',
  message: 'GATT Error: Not supported.'
}].forEach(testSpec => {
  sequential_promise_test(() => {
    testRunner.setBluetoothMockDataSet('FailingGATTOperationsAdapter');
    return requestDeviceWithKeyDown({filters: [{services: [errorUUID(0xA0)]}]})
      .then(device => device.connectGATT())
      .then(gattServer => gattServer.getPrimaryService(errorUUID(0xA0)))
      .then(service => service.getCharacteristic(testSpec.uuid))
      .then(function(characteristic) {
        return characteristic.writeValue(new Uint8Array([1])).then(() => {
          assert_unreached('Trying to write the characteristic fails. Promise should reject.');
        }, function(e) {
          assert_equals(e.name, testSpec.errorType);
          assert_equals(e.message, testSpec.message);
        });
      });
  }, testSpec.testName);
});

sequential_promise_test(function() {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return requestDeviceWithKeyDown({
    filters: [{services: ['generic_access']}]
  }).then(function(device) {
    return device.connectGATT();
  }).then(function(gattServer) {
    return gattServer.getPrimaryService('generic_access');
  }).then(function(service) {
    return service.getCharacteristic('device_name');
  }).then(function(characteristic) {
    return characteristic.writeValue(new Uint8Array(513 /* length */)).then(function() {
      assert_unreached('Value is too long. Should fail.');
    }, function(e) {
      assert_equals(e.name, 'InvalidModificationError');
      assert_equals(e.message, 'Value can\'t exceed 512 bytes.');
    });
  });
}, 'Trying to write more than 512 bytes should return an error.');

sequential_promise_test(function() {
  testRunner.setBluetoothMockDataSet('GenericAccessAdapter');
  return requestDeviceWithKeyDown({
    filters: [{services: ['generic_access']}]
  }).then(function(device) {
    return device.connectGATT();
  }).then(function(gattServer) {
    return gattServer.getPrimaryService('generic_access');
  }).then(function(service) {
    return service.getCharacteristic('device_name');
  }).then(function(characteristic) {
    return Promise.all([characteristic.writeValue(new Uint8Array(1 /* length */)),
                       characteristic.writeValue(new ArrayBuffer(1 /* length */)),
                       characteristic.writeValue(new DataView(new ArrayBuffer(1 /* length */)))]);
  });
}, 'A regular write request to a writable characteristic should succeed.');
</script>
