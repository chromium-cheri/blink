<!doctype html>
<html>
  <head>
    <script src="../resources/js-test.js"></script>
    <script src="resources/compatibility.js"></script>
    <script src="resources/audio-testing.js"></script>
  </head>

  <body>
    <script>
      description('Basic test for OfflineAudioContext.suspend() and OfflineAudioContext.resume().');
      window.jsTestIsAsync = true;

      var sampleRate = 44100;
      var renderDuration = 1;
      var renderQuantum = 128;

      var audit = Audit.createTaskRunner();

      // Task: Calling suspend with no argument or negative time should
      // reject the promise.
      audit.defineTask('suspend-invalid-argument', function (done) {
        var context = new OfflineAudioContext(1, sampleRate * renderDuration, sampleRate);

        Should('context.suspend()', context.suspend()).beRejected();
        Should('context.suspend(-1.0)', context.suspend(-1.0)).beRejected().then(done);
      });

      // Task: Scheduling a suspend in the past should be rejected.
      audit.defineTask('suspend-in-the-past', function (done) {
        var context = new OfflineAudioContext(1, sampleRate * renderDuration, sampleRate);

        context.suspend(0.5).then(function () {
          Should('Scheduling a suspend in the past', 
            context.suspend(context.currentTime - 0.1)).beRejected();
          context.resume();
        });

        context.startRendering().then(done);
      });

      // Task: Calling multiple suspends at the same rendering quantum should
      // reject the promise.
      audit.defineTask('identical-suspend-time', function (done) {
        var context = new OfflineAudioContext(1, sampleRate * renderDuration, sampleRate);

        // |suspendTime1| and |suspendTime2| are identical when quantized to
        // the render quantum size.
        var suspendTime1 = renderQuantum / sampleRate;
        var suspendTime2 = (renderQuantum + renderQuantum * 0.5) / sampleRate;

        context.suspend(suspendTime1);

        Should('Calling multiple suspends at the same rendering quantum',
          context.suspend(suspendTime2)).beRejected().then(done);
      });

      // Task: Resuming the context before the actual suspension happens.
      audit.defineTask('resume-before-suspend', function (done) {
        var context = new OfflineAudioContext(1, sampleRate * renderDuration, sampleRate);

        // A suspend is scheduled at the half.
        context.suspend(renderDuration * 0.5).then(done);

        // We have to start rendering to get the time running.
        context.startRendering();

        // Then call resume() immediately after the rendering starts. This
        // resume() will be performed before the actual suspension happens.
        Should('Resuming before suspend', context.resume()).beRejected();
      });

      // Task: Calling resume on non-suspended context should reject the promise.
      audit.defineTask('resume-without-suspend', function (done) {
        var context = new OfflineAudioContext(1, sampleRate * renderDuration, sampleRate);

        Should('Calling resume on non-suspended context', context.resume())
          .beRejected().then(done);
      });

      audit.defineTask('finish', function (done) {
        finishJSTest();
        done();
      });

      audit.runTasks(
        'suspend-invalid-argument',
        'suspend-in-the-past',
        'identical-suspend-time',
        'resume-before-suspend',
        'resume-without-suspend',
        'finish'
      );

      successfullyParsed = true;
    </script>

  </body>
</html>
