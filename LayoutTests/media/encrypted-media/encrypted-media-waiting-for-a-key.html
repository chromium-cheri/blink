<!DOCTYPE html>
<html>
    <head>
        <title>Waiting for a key.</title>
        <script src="encrypted-media-utils.js"></script>
        <script src="../../resources/testharness.js"></script>
        <script src="../../resources/testharnessreport.js"></script>
    </head>
    <body>
        <video id="testVideo"></video>
        <div id="log"></div>
        <script>
            promise_test(function(test)
            {
                var video = document.getElementById('testVideo');
                var mediaKeySession;

                // As this code doesn't wait for the 'message' event to avoid
                // race conditions with 'waitingforkey', specify the key ID and
                // key used by the encrypted content.
                var keyId = stringToUint8Array('0123456789012345');
                var rawKey = new Uint8Array([0xeb, 0xdd, 0x62, 0xf1, 0x68, 0x14, 0xd2, 0x7b,
                                             0x68, 0xef, 0x12, 0x2a, 0xfc, 0xe4, 0xae, 0x3c]);

                return navigator.requestMediaKeySystemAccess('org.w3.clearkey', [{}]).then(function(access) {
                    return access.createMediaKeys();
                }).then(function(mediaKeys) {
                    return video.setMediaKeys(mediaKeys);
                }).then(function() {
                    video.src = '../content/test-encrypted.webm';
                    video.play();
                    return wait_for_encrypted_event(video);
                }).then(function(e) {
                    // Received the 'encrypted' event(s), so create a session.
                    mediaKeySession = video.mediaKeys.createSession();
                    return mediaKeySession.generateRequest(e.initDataType, e.initData);
                }).then(function() {
                    // Wait until the video indicates that it needs a key to
                    // continue. generateRequest() will cause a 'message' event
                    // to occur specifying the keyId that is needed, but we
                    // ignore it since we already know what keyId is needed and
                    // this avoids a race condition between it and the
                    // 'waitingforkey' event.
                    return wait_for_waitingforkey_event(video);
                }).then(function() {
                    // Make sure the video is NOT paused and not progressing
                    // before the session is updated. This requires the video
                    // to NOT have a clear lead.
                    assert_false(video.paused);
                    assert_equals(video.currentTime, 0);

                    // Add the key needed to decrypt.
                    var jwkSet = stringToUint8Array(createJWKSet(createJWK(keyId, rawKey)));
                    return mediaKeySession.update(jwkSet);
                }).then(function() {
                    // Video should start playing now that it can decrypt the
                    // streams, so wait until a little bit of the video has
                    // played.
                    return wait_for_timeupdate_event(video);
                });
            }, 'Waiting for a key.');

            // Wait for a pair of 'encrypted' events. Promise resolved on
            // second event.
            function wait_for_encrypted_event(video)
            {
                var encryptedEventCount = 0;
                return new Promise(function(resolve) {
                    video.addEventListener('encrypted', function listener(e) {
                        assert_equals(e.target, video);
                        assert_true(e instanceof window.MediaEncryptedEvent);
                        assert_equals(e.type, 'encrypted');

                        // The same decryption key is used by both the audio
                        // and the video streams so wait for the second event
                        // to ensure we see both events.
                        if (++encryptedEventCount != 2)
                            return;

                        video.removeEventListener(listener);
                        resolve(e);
                    });
                });
            };

            // Wait for a 'waitingforkey' event. Promise resolved when the
            // event is received.
            function wait_for_waitingforkey_event(video)
            {
                var waitingForKeyEventCount = 0;
                return new Promise(function(resolve) {
                    video.addEventListener('waitingforkey', function listener(e) {
                        assert_equals(e.target, video);
                        assert_equals(e.type, 'waitingforkey');

                        ++waitingForKeyEventCount;
                        // TODO(jrummell): waitingforkey event should only
                        // occur once. http://crbug.com/461903
//                      assert_equals(waitingForKeyEventCount, 1, 'Multiple waitingforkey events');

                        video.removeEventListener(listener);
                        resolve(e);
                    });
                });
            };

            // Wait for a 'timeupdate' event. Promise resolved if |video| has
            // played for more than 0.2 seconds.
            function wait_for_timeupdate_event(video)
            {
                return new Promise(function(resolve) {
                    video.addEventListener('timeupdate', function listener(e) {
                        assert_equals(e.target, video);
                        if (video.currentTime < 0.2)
                            return;
                        video.removeEventListener(listener);
                        resolve(e);
                    });
                });
            };
        </script>
    </body>
</html>
